<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ROMPETUTI - Phaser Web</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; }
    canvas { display: block; }
    #rotate-device-message {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.9); color: white; z-index: 9999; text-align: center;
      padding-top: 40vh; font-size: 20px; font-family: sans-serif; box-sizing: border-box;
      padding-left: 10px; padding-right: 10px;
    }
    #fullscreen-button {
        position: fixed; top: 10px; right: 10px; z-index: 10000; padding: 8px 12px;
        background-color: rgba(0, 0, 0, 0.6); color: white; border: 1px solid white;
        border-radius: 5px; font-size: 14px; cursor: pointer; display: none;
    }
  </style>
</head>
<body>
  <div id="rotate-device-message">
    Por favor, rota tu dispositivo a modo horizontal para jugar.
  </div>
  <button id="fullscreen-button">Pantalla Completa</button>

<script>
window.onload = () => {
  const rotateMessage = document.getElementById('rotate-device-message');
  const fullscreenButton = document.getElementById('fullscreen-button');
  let game = null;

  function enterFullscreen() {
    const elem = document.documentElement;
    if (elem.requestFullscreen) {
      elem.requestFullscreen().catch(err => { console.error(`Error fullscreen: ${err.message}`); });
    } else if (elem.mozRequestFullScreen) { elem.mozRequestFullScreen(); }
    else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); }
    else if (elem.msRequestFullscreen) { elem.msRequestFullscreen(); }
    if (fullscreenButton) fullscreenButton.style.display = 'none';
  }

   if (fullscreenButton) {
       fullscreenButton.addEventListener('click', enterFullscreen);
   }

  function checkOrientation() {
    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
    if (isPortrait) {
      rotateMessage.style.display = 'block';
      if (fullscreenButton) fullscreenButton.style.display = 'none';
       if (game && game.isBooted && game.scene.isActive('default')) { game.scene.pause('default'); }
       if (window.musicaIntro && window.musicaIntro.isPlaying) window.musicaIntro.stop();
      return false;
    } else {
      rotateMessage.style.display = 'none';
       if (fullscreenButton && (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) && !document.fullscreenElement) {
           fullscreenButton.style.display = 'block';
       }
      if (game && game.isBooted) {
          if (game.scene.isPaused('default')) { game.scene.resume('default'); }
          if (!window.jugando && window.pantallaInicio && window.pantallaInicio.visible && window.musicaIntro && !window.musicaIntro.isPlaying) { window.musicaIntro.play(); }
      } else if (!game) { initializeGame(); }
      return true;
    }
  }

  function initializeGame() {
    const config = {
      type: Phaser.AUTO,
      backgroundColor: '#000000',
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: window.innerWidth,
        height: window.innerHeight,
      },
       input: { activePointers: 1 },
      scene: {
        init: function() { /* ... variables ... */
            this.pantallaInicio = null; this.pantallaGameOver = null; this.fondo = null; this.rompetuti = null; this.inodoro = null;
            this.startButton = null; this.restartButton = null; this.exitButton = null;
            this.pinturas = []; this.manchas = [];
            this.cacometro = 0; this.banio = 0; this.nivel = 1; this.puntaje = 0;
            this.timer = 0; this.dirTimer = 0;
            this.jugando = false; this.gameOver = false;
            this.sonidoPintura = null; this.sonidoNivel = null; this.sonidoGameOver = null; window.musicaIntro = null;
            this.graphics = null; this.cacoText = null; this.banioText = null;
            window.jugando = false; window.pantallaInicio = null;
         },
        preload: preload, create: create, update: update
      }
    };
    game = new Phaser.Game(config);
    window.game = game;
  }

  function preload() { /* ... (sin cambios) ... */
    for (let i = 1; i <= 4; i++) this.load.image(`fondo${i}`, `assets/fondo${i}.png`);
    this.load.image('pantallaInicio', 'assets/pantalla_inicio.png');
    this.load.image('pantallaGameOver', 'assets/pantalla_gameover.png');
    this.load.image('rompetuti', 'assets/rompetuti.png');
    this.load.image('rompetuti2','assets/rompetuti2.png');
    this.load.image('inodoro', 'assets/inodoro.png');
    this.load.audio('pintura', 'assets/pintura.mp3');
    this.load.audio('nivel',   'assets/nivel.mp3');
    this.load.audio('perdiste','assets/perdiste.mp3');
    this.load.audio('intro',   'assets/intro.mp3');
  }

  function create() {
    window.musicaIntro = this.sound.add('intro', { loop: true, volume: 0.5 });
    if (checkOrientation() && !window.musicaIntro.isPlaying) { window.musicaIntro.play(); }

    this.pantallaInicio = this.add.image(0, 0, 'pantallaInicio').setOrigin(0).setDepth(10)
      .setDisplaySize(this.scale.width, this.scale.height).setInteractive();
    window.pantallaInicio = this.pantallaInicio;

    this.pantallaGameOver = this.add.image(0, 0, 'pantallaGameOver').setOrigin(0).setDepth(10)
      .setDisplaySize(this.scale.width, this.scale.height).setVisible(false);

    this.fondo = this.add.image(0, 0, 'fondo1').setOrigin(0).setDepth(0)
      .setDisplaySize(this.scale.width, this.scale.height);

    // --- Define tamaños iniciales basados en la pantalla inicial ---
    const initialH = this.scale.height;
    const initialW = this.scale.width;

    const originalRompetutiWidth = 160; const originalRompetutiHeight = 200;
    let scaleFactorHeight = initialH / 1080; // Altura referencia
    let initialRompetutiHeight = Phaser.Math.Clamp(originalRompetutiHeight * scaleFactorHeight, 100, 300);
    let scaleRatio = initialRompetutiHeight / originalRompetutiHeight;
    let initialRompetutiWidth = originalRompetutiWidth * scaleRatio;

    this.rompetuti = this.add.sprite(initialW / 2, 100, 'rompetuti').setDepth(1)
      .setDisplaySize(initialRompetutiWidth, initialRompetutiHeight);


    const originalInodoroWidth = 240; const originalInodoroHeight = 120;
    scaleFactorHeight = initialH / 1080; // Reusa o re-calcula si es necesario
    let initialInodoroHeight = Phaser.Math.Clamp(originalInodoroHeight * scaleFactorHeight, 60, 180);
    scaleRatio = initialInodoroHeight / originalInodoroHeight;
    let initialInodoroWidth = originalInodoroWidth * scaleRatio;
    let initialInodoroY = initialH - (initialInodoroHeight / 2) - 20;

    this.inodoro = this.add.sprite(initialW / 2, initialInodoroY, 'inodoro').setDepth(1)
      .setDisplaySize(initialInodoroWidth, initialInodoroHeight);
    //----------------------------------------------------------------

    this.sonidoPintura  = this.sound.add('pintura');
    this.sonidoNivel    = this.sound.add('nivel');
    this.sonidoGameOver = this.sound.add('perdiste');

    this.graphics  = this.add.graphics().setDepth(2);
    // Ajusta tamaño fuente UI si es necesario
    const uiFontSize = Math.max(16, Math.min(24, this.scale.width / 40)) + 'px'; // Ejemplo de fuente escalable
    this.cacoText  = this.add.text(10, 10, 'CACÓMETRO', { fontSize: uiFontSize, fill: '#000', stroke: '#fff', strokeThickness: 1 }).setDepth(2);
    this.banioText = this.add.text(this.scale.width - 10, 10, 'BAÑO EXPLOTADO', { fontSize: uiFontSize, fill: '#000', stroke: '#fff', strokeThickness: 1 })
      .setOrigin(1, 0).setDepth(2);

    this.startButton = this.add.text(this.scale.width/2, this.scale.height - 80, 'COMENZAR PARTIDA',
      { fontSize: '32px', fill: '#fff', backgroundColor: '#000', padding: { x:10,y:5 } })
      .setOrigin(0.5).setDepth(11).setInteractive({ useHandCursor: true });

    this.startButton.on('pointerdown', () => {
      if (!checkOrientation()) return;
      enterFullscreen();
      this.pantallaInicio.setVisible(false); this.startButton.setVisible(false);
      if (window.musicaIntro && window.musicaIntro.isPlaying) window.musicaIntro.stop();
      this.jugando = true; window.jugando = true;
      if (this.scene.isPaused()) { this.scene.resume(); }
    });

    // --- Manejo de Redimensionamiento (CON CORRECCIÓN APLICADA) ---
    this.scale.on('resize', (gameSize) => {
        const isLandscape = checkOrientation();
        const w = gameSize.width;
        const h = gameSize.height;

        if (this.pantallaInicio) this.pantallaInicio.setDisplaySize(w, h);
        if (this.pantallaGameOver) this.pantallaGameOver.setDisplaySize(w, h);
        if (this.fondo) this.fondo.setDisplaySize(w, h);

        // --- Redimensionar y Reposicionar Sprites Principales ---
        if (this.rompetuti) {
            const originalRompetutiWidth = 160; const originalRompetutiHeight = 200;
            const scaleFactorHeight = h / 1080;
            const newRompetutiHeight = Phaser.Math.Clamp(originalRompetutiHeight * scaleFactorHeight, 80, 250); // Ajusta límites si es necesario
            const scaleRatio = newRompetutiHeight / originalRompetutiHeight;
            const newRompetutiWidth = originalRompetutiWidth * scaleRatio;

            this.rompetuti.setDisplaySize(newRompetutiWidth, newRompetutiHeight);
            const margin = w * 0.1; // Margen relativo
            const rompetutiHalfWidth = this.rompetuti.displayWidth / 2;
            const rompetutiY = h * 0.15; // Posición Y relativa a la altura
            this.rompetuti.setPosition(
                Phaser.Math.Clamp(this.rompetuti.x, margin + rompetutiHalfWidth, w - margin - rompetutiHalfWidth),
                rompetutiY
            );
        }

        if (this.inodoro) {
            const originalInodoroWidth = 240; const originalInodoroHeight = 120;
            const scaleFactorHeight = h / 1080;
            const newInodoroHeight = Phaser.Math.Clamp(originalInodoroHeight * scaleFactorHeight, 50, 150); // Ajusta límites
            const scaleRatio = newInodoroHeight / originalInodoroHeight;
            const newInodoroWidth = originalInodoroWidth * scaleRatio;

            this.inodoro.setDisplaySize(newInodoroWidth, newInodoroHeight);
            const inodoroHalfWidth = this.inodoro.displayWidth / 2;
            const inodoroHalfHeight = this.inodoro.displayHeight / 2;
            const inodoroY = h - inodoroHalfHeight - (h * 0.05); // Posición Y relativa al fondo
             this.inodoro.setPosition(
                Phaser.Math.Clamp(this.inodoro.x, inodoroHalfWidth, w - inodoroHalfWidth),
                inodoroY
            );
        }
        // --- Fin Redimensionamiento Sprites ---

        // Ajusta textos UI y botones
        const uiFontSize = Math.max(16, Math.min(24, w / 40)) + 'px'; // Recalcula tamaño fuente
        if (this.cacoText) this.cacoText.setPosition(10, 10).setFontSize(uiFontSize);
        if (this.banioText) this.banioText.setPosition(w - 10, 10).setOrigin(1,0).setFontSize(uiFontSize);
        if (this.startButton) this.startButton.setPosition(w/2, h - 80);
        if (this.restartButton) this.restartButton.setPosition(w/2 - 100, h - 80);
        if (this.exitButton) this.exitButton.setPosition(w/2 + 100, h - 80);

        // Redibuja barras de UI
        if(this.graphics && isLandscape) {
            this.graphics.clear();
            const barWidth = Math.min(200, w * 0.25); // Ancho relativo barras
            const barHeight = Math.max(15, Math.min(25, h * 0.025)); // Alto relativo barras
            const textHeight = parseFloat(uiFontSize); // Usa tamaño de fuente calculado
            const textMargin = 10;
            const barY = textMargin + textHeight + 5; // Posiciona barras debajo del texto

            this.graphics.lineStyle(2, 0x000000).strokeRect(textMargin, barY, barWidth, barHeight);
            this.graphics.fillStyle(0x00ff00, 1).fillRect(textMargin + 2, barY + 2, Math.max(0, (barWidth - 4) * (this.cacometro / 100)), barHeight - 4);

            const banioBarX = w - barWidth - textMargin;
            this.graphics.lineStyle(2, 0x000000).strokeRect(banioBarX, barY, barWidth, barHeight);
            let fillWidth = Math.max(0, (barWidth - 4) * (this.banio / 100));
            this.graphics.fillStyle(0x8B4513, 1).fillRect(banioBarX + barWidth - 2 - fillWidth, barY + 2, fillWidth, barHeight - 4);
        }
    }); // Fin del listener resize

    this.input.on('pointermove', (pointer) => { /* ... (sin cambios) ... */
         if (this.jugando && !this.gameOver && pointer.isDown) {
            const inodoroWidth = this.inodoro.displayWidth;
            this.inodoro.x = Phaser.Math.Clamp(pointer.x, inodoroWidth / 2, this.scale.width - inodoroWidth / 2);
        }
    });
     this.input.on('pointerdown', (pointer) => { /* ... (sin cambios) ... */
          if (this.jugando && !this.gameOver) {
             const inodoroWidth = this.inodoro.displayWidth;
             this.inodoro.x = Phaser.Math.Clamp(pointer.x, inodoroWidth / 2, this.scale.width - inodoroWidth / 2);
         }
     });
  } // Fin de create

  function update(time, delta) { /* ... (sin cambios relativos al resize, pero asegurando uso de this.scale.width/height donde aplique) ... */
     if (!this.jugando || this.gameOver) return;

    // Controles Teclado
    const cursors = this.input.keyboard.createCursorKeys();
    const speed = (8 + this.nivel) * (delta / 16.67); // Velocidad ajustada a delta time
    const inodoroHalfWidth = this.inodoro.displayWidth / 2;
    if (cursors.left.isDown)  this.inodoro.x = Phaser.Math.Clamp(this.inodoro.x - speed, inodoroHalfWidth, this.scale.width - inodoroHalfWidth);
    if (cursors.right.isDown) this.inodoro.x = Phaser.Math.Clamp(this.inodoro.x + speed, inodoroHalfWidth, this.scale.width - inodoroHalfWidth);

    // Movimiento Rompetuti
    if (this.rompetuti.vx === undefined) { this.rompetuti.vx = 6 * (Math.random() < 0.5 ? -1 : 1); }
    const margin = this.scale.width * 0.1; // Margen relativo
    const rompetutiHalfWidth = this.rompetuti.displayWidth / 2;
    this.rompetuti.x += this.rompetuti.vx * (delta / 16.67); // Ajustado a delta
    if (this.rompetuti.x < margin + rompetutiHalfWidth || this.rompetuti.x > this.scale.width - margin - rompetutiHalfWidth) {
        this.rompetuti.vx *= -1;
        this.rompetuti.x = Phaser.Math.Clamp(this.rompetuti.x, margin + rompetutiHalfWidth, this.scale.width - margin - rompetutiHalfWidth);
    }

    this.dirTimer += delta;
    if (this.dirTimer > 1500) {
      this.dirTimer = 0;
      let nv = Phaser.Math.Between(4, 6 + this.nivel);
      this.rompetuti.vx = (Math.random() < 0.5 ? -nv : nv); // La velocidad base ya está ajustada a delta
    }

    // Disparo Rompetuti
    this.timer += delta;
    const spawnRate = Math.max(160, 1000 - this.nivel * 80);
    if (this.timer > spawnRate) {
      this.timer = 0;
      // Asegura que la pintura salga desde el rompetuti redimensionado
      let pinta = this.add.rectangle(this.rompetuti.x, this.rompetuti.y + this.rompetuti.displayHeight / 2 + 10, 10, 20, 0x8B4513).setDepth(1);
      this.pinturas.push(pinta);
      if (this.sonidoPintura) this.sonidoPintura.play();
    }

    // Lógica Pinturas
    const fallSpeed = (6 + this.nivel) * (delta / 16.67); // Ajustado a delta
    for (let i = this.pinturas.length - 1; i >= 0; i--) {
        let p = this.pinturas[i];
        if (!p.scene) continue; // Si ya fue destruida en otro frame, salta
        p.y += fallSpeed;

        if (Phaser.Geom.Intersects.RectangleToRectangle(p.getBounds(), this.inodoro.getBounds())) {
            p.destroy(); this.pinturas.splice(i, 1);
            this.cacometro = Math.min(100, this.cacometro + 10); this.puntaje += 10;
        } else if (p.y > this.scale.height + 20) {
            this.manchas.push(this.add.circle(p.x, this.scale.height - 10, 6, 0x8B4513).setDepth(0)); // Podrías escalar el tamaño de la mancha también
            this.banio = Math.min(100, this.banio + 10);
            p.destroy(); this.pinturas.splice(i, 1);
        }
    }

    // Nivel up
    if (this.cacometro >= 100) {
      this.cacometro = 0; this.nivel++;
      this.fondo.setTexture(`fondo${(this.nivel - 1) % 4 + 1}`);
      if (this.sonidoNivel) this.sonidoNivel.play();
      // Podrías añadir un efecto visual o de texto para "Nivel Subido" aquí
    }

    // Game Over
    if (this.banio >= 100 && !this.gameOver) {
      this.gameOver = true; this.jugando = false; window.jugando = false;
      if (this.sonidoGameOver) this.sonidoGameOver.play();
      if (window.musicaIntro && window.musicaIntro.isPlaying) window.musicaIntro.stop();
      this.pantallaGameOver.setVisible(true).setDisplaySize(this.scale.width, this.scale.height);
      const w = this.scale.width; const h = this.scale.height;
      if (!this.restartButton) { /* ... crear botón ... */
        this.restartButton = this.add.text(w/2 - 100, h - 80, 'VOLVER A EMPEZAR', { /*...*/ }).setOrigin(0.5).setDepth(11).setInteractive({ useHandCursor: true });
        this.restartButton.on('pointerdown', () => window.location.reload());
      } else { this.restartButton.setPosition(w/2 - 100, h - 80).setVisible(true); }
       if (!this.exitButton) { /* ... crear botón ... */
         this.exitButton = this.add.text(w/2 + 100, h - 80, 'SALIR', { /*...*/ }).setOrigin(0.5).setDepth(11).setInteractive({ useHandCursor: true });
         this.exitButton.on('pointerdown', () => window.location.reload());
       } else { this.exitButton.setPosition(w/2 + 100, h - 80).setVisible(true); }
    }
  } // Fin de update

  // --- Inicialización y listeners globales ---
  if (checkOrientation()) { initializeGame(); }
  window.addEventListener('resize', () => { checkOrientation(); });
  if (window.screen.orientation) { window.screen.orientation.addEventListener('change', checkOrientation); }
  else { window.addEventListener('orientationchange', checkOrientation); }
   if (fullscreenButton && !(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)) {
       fullscreenButton.style.display = 'none'; console.log("Fullscreen API no soportada.");
   }

}; // Fin de window.onload
</script>
</body>
</html>
